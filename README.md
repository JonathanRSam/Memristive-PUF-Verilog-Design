# Memristive-PUF-Verilog-Design

This repository contains a Verilog-based implementation of a **memristor-based Physical Unclonable Function (PUF)** using a crossbar architecture. The design models memristive behavior digitally and builds a PUF by composing multiple memristor instances into a structured array. The project is intended for simulation and experimentation rather than hardware synthesis.

---

## Project Overview

The PUF design is based on a memristive crossbar architecture where:

* **Challenge bits** are applied as voltage stimuli to the rows of a memristor array
* **Response bits** are generated by comparing aggregate conductance values across column pairs
* **Randomized memristor parameters** introduce device-level variability, enabling uniqueness across instances

Each memristor is modeled using a dedicated Verilog module that captures threshold-based conductance updates, fixed-point arithmetic, and randomized device characteristics. The PUF behavior emerges from the collective interaction of these memristors within the crossbar.

---

## Repository Structure

The main files in this repository are:

* **`MemRan.v`**
  Implements the memristor model. Each instance represents a single memristive device with:

  * Internally stored conductance state
  * Randomized threshold voltage and mobility coefficient
  * Fixed-point arithmetic for voltage and conductance
  * Threshold-based conductance update behavior

* **`MemPUF.v`**
  Top-level PUF module. This module:

  * Instantiates a memristor crossbar using the `MemRan` module
  * Maps challenge bits and inverted challenge bits to row voltages
  * Aggregates conductance values column-wise
  * Generates response bits via pairwise column comparisons

* **`TB_MemPUF.v`**
  Testbench for simulating the `MemPUF` module. This file:

  * Generates the clock and reset signals
  * Applies a challenge vector
  * Captures and displays the PUF response
  * Re-applies the same challenge to verify response stability

---

## Top-Level Module

The **top-level design module is `MemPUF`**.

Key parameters:

* `N_CHAL` – Number of challenge bits
* `N_RESP` – Number of response bits
* `VIN_WIDTH` – Bit width of the fixed-point voltage representation
* `G_WIDTH` – Bit width of the conductance representation
* `FRAC_BITS` – Number of fractional bits used in fixed-point arithmetic

The size of the memristor array is determined directly from these parameters:

* Rows = `2 * N_CHAL`
* Columns = `2 * N_RESP`
* Total memristors = `(2 * N_CHAL) * (2 * N_RESP)`

---

## How the PUF Works (High-Level)

1. Each challenge bit controls **two rows** in the crossbar:

   * One row driven by the challenge bit
   * One row driven by the inverted challenge bit

2. These row voltages are applied to all memristors connected to that row.

3. Each memristor updates its conductance based on:

   * The applied voltage
   * Its internally randomized parameters

4. Conductances are summed **column-wise**.

5. Each response bit is generated by comparing two adjacent column sums:

   * If column A > column B → response bit = 1
   * Else → response bit = 0

---

## Running the Simulation

1. Compile all Verilog files:

   * `MemRan.v`
   * `MemPUF.v`
   * `TB_MemPUF.v`

2. Set `TB_MemPUF` as the top-level module in your simulator.

3. Run the simulation.

The testbench will:

* Apply a single challenge vector
* Display the generated response
* Reset the system
* Re-apply the same challenge
* Check whether the response remains stable

---

## Modifying the Testbench

You can experiment with different PUF behaviors by editing **`TB_MemPUF.v`**:

* Change the challenge value:

  ```verilog
  C = 8'b1010_1001;
  ```

* Modify `N_CHAL` or `N_RESP` to change the size of the PUF.

* Adjust simulation timing to observe conductance evolution over longer or shorter intervals.

Each simulation run represents a unique PUF instance due to randomized memristor initialization, while repeated evaluations within the same run should produce stable responses for identical challenges.

---

## Notes

* This design is intended for **simulation and analysis**, not direct hardware synthesis.
* Randomized behavior is implemented using Verilog’s pseudo-random functions during initialization.
* Fixed-point arithmetic is used throughout to approximate analog memristive behavior.


G. S. Rose and C. A. Meade, *“Performance Analysis of a Memristive Crossbar PUF Design,”* Proceedings of the Design Automation Conference (DAC), 2015.
